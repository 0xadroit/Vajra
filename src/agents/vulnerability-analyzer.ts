/**
 * Vajra - AI-Powered Security Scanner
 * Vulnerability Analyzer - Scans for security vulnerabilities
 */

import axios, { AxiosInstance, AxiosResponse } from 'axios';
import {
  VajraConfig,
  TargetInfo,
  Vulnerability,
  VulnerabilityType,
  ScanModule,
  ScanResult,
  ScanContext,
  ScanCoverage,
  Endpoint,
  Parameter,
  Evidence,
  HTTPRequest,
  HTTPResponse,
  SeverityLevel,
  AIEngine,
  Logger,
  ProofOfConcept,
} from '../types/index.js';
import { BrowserManager } from '../core/browser-manager.js';
import { v4 as uuidv4 } from 'uuid';

// ============================================================================
// Vulnerability Analyzer
// ============================================================================

export class VulnerabilityAnalyzer {
  private module: ScanModule;
  private config: VajraConfig;
  private aiEngine: AIEngine;
  private browserManager: BrowserManager;
  private logger: Logger;
  private httpClient: AxiosInstance;
  private vulnerabilities: Vulnerability[] = [];
  
  constructor(
    module: ScanModule,
    config: VajraConfig,
    aiEngine: AIEngine,
    browserManager: BrowserManager,
    logger: Logger
  ) {
    this.module = module;
    this.config = config;
    this.aiEngine = aiEngine;
    this.browserManager = browserManager;
    this.logger = logger;
    
    this.httpClient = axios.create({
      timeout: config.scanning.timeout,
      headers: {
        'User-Agent': config.scanning.userAgent || 'Vajra/1.0 Security Scanner',
        ...config.scanning.headers,
      },
      validateStatus: () => true,
    });
  }
  
  /**
   * Run the vulnerability scan
   */
  async scan(targetInfo: TargetInfo): Promise<ScanResult> {
    const startTime = Date.now();
    let endpointsTested = 0;
    let parametersTested = 0;
    let payloadsUsed = 0;
    
    this.logger.info(`Starting ${this.module} vulnerability scan`);
    
    try {
      const scanner = this.getScanner();
      
      for (const endpoint of targetInfo.endpoints) {
        endpointsTested++;
        
        for (const param of endpoint.parameters) {
          parametersTested++;
          
          const payloads = await this.generatePayloads(endpoint, param);
          payloadsUsed += payloads.length;
          
          for (const payload of payloads) {
            const result = await scanner(endpoint, param, payload);
            
            if (result) {
              this.vulnerabilities.push(result);
            }
            
            // Respect rate limiting
            if (this.config.scanning.delayBetweenRequests) {
              await this.delay(this.config.scanning.delayBetweenRequests);
            }
          }
        }
      }
      
      return {
        scannerId: `${this.module}-scanner`,
        scannerType: this.module,
        status: 'completed',
        vulnerabilities: this.vulnerabilities,
        coverage: {
          endpointsTested,
          totalEndpoints: targetInfo.endpoints.length,
          parametersTested,
          totalParameters: targetInfo.parameters.length,
          payloadsUsed,
        },
        duration: Date.now() - startTime,
      };
    } catch (error) {
      this.logger.error(`${this.module} scan failed`, { error: String(error) });
      
      return {
        scannerId: `${this.module}-scanner`,
        scannerType: this.module,
        status: 'failed',
        vulnerabilities: this.vulnerabilities,
        coverage: {
          endpointsTested,
          totalEndpoints: targetInfo.endpoints.length,
          parametersTested,
          totalParameters: targetInfo.parameters.length,
          payloadsUsed,
        },
        errors: [String(error)],
        duration: Date.now() - startTime,
      };
    }
  }
  
  /**
   * Get the appropriate scanner function
   */
  private getScanner(): ScannerFunction {
    switch (this.module) {
      case 'xss':
        return this.scanXSS.bind(this);
      case 'sqli':
        return this.scanSQLi.bind(this);
      case 'ssrf':
        return this.scanSSRF.bind(this);
      case 'auth-bypass':
        return this.scanAuthBypass.bind(this);
      case 'idor':
        return this.scanIDOR.bind(this);
      case 'lfi':
        return this.scanLFI.bind(this);
      case 'command-injection':
        return this.scanCommandInjection.bind(this);
      case 'xxe':
        return this.scanXXE.bind(this);
      case 'cors':
        return this.scanCORS.bind(this);
      case 'security-headers':
        return this.scanSecurityHeaders.bind(this);
      default:
        return this.genericScan.bind(this);
    }
  }
  
  /**
   * Generate payloads using AI
   */
  private async generatePayloads(endpoint: Endpoint, param: Parameter): Promise<string[]> {
    const vulnType = this.moduleToVulnType(this.module);
    
    return await this.aiEngine.generatePayloads(vulnType, {
      endpoint,
      parameter: param,
    });
  }
  
  /**
   * Convert scan module to vulnerability type
   */
  private moduleToVulnType(module: ScanModule): VulnerabilityType {
    const mapping: Record<ScanModule, VulnerabilityType> = {
      'reconnaissance': 'information-disclosure',
      'xss': 'xss-reflected',
      'sqli': 'sqli-error',
      'ssrf': 'ssrf',
      'auth-bypass': 'auth-bypass',
      'idor': 'idor',
      'lfi': 'lfi',
      'rfi': 'rfi',
      'command-injection': 'command-injection',
      'xxe': 'xxe',
      'csrf': 'csrf',
      'cors': 'cors-misconfiguration',
      'security-headers': 'missing-security-header',
      'ssl-tls': 'ssl-tls-issue',
      'information-disclosure': 'information-disclosure',
    };
    
    return mapping[module] || 'information-disclosure';
  }
  
  // ============================================================================
  // XSS Scanner
  // ============================================================================
  
  private async scanXSS(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    const evidence = await this.sendPayload(endpoint, param, payload);
    
    if (!evidence) return null;
    
    // Check for reflection in response
    const reflected = evidence.response.body.includes(payload);
    
    // Check for unencoded reflection
    const unencoded = this.checkUnEncodedReflection(evidence.response.body, payload);
    
    // Use browser to check for actual XSS execution
    let executed = false;
    if (reflected || unencoded) {
      executed = await this.checkXSSExecution(endpoint, param, payload);
    }
    
    if (executed) {
      const classification = await this.aiEngine.classifyVulnerability(evidence);
      
      return this.createVulnerability({
        type: this.determineXSSType(evidence, payload),
        severity: 'high',
        title: `Cross-Site Scripting (XSS) in ${param.name}`,
        description: `A cross-site scripting vulnerability was found in the ${param.name} parameter. The payload was executed in the browser context.`,
        url: endpoint.url,
        parameter: param.name,
        payload,
        evidence,
        remediation: await this.aiEngine.suggestRemediation({
          id: uuidv4(),
          type: 'xss-reflected',
          severity: 'high',
          title: 'XSS Vulnerability',
          description: 'XSS found',
          url: endpoint.url,
          evidence,
          remediation: '',
          references: [],
          timestamp: new Date(),
          verified: true,
        }),
      });
    }
    
    return null;
  }
  
  private checkUnEncodedReflection(body: string, payload: string): boolean {
    // Check if dangerous characters are not encoded
    const dangerousChars = ['<', '>', '"', "'", '`'];
    for (const char of dangerousChars) {
      if (payload.includes(char) && body.includes(payload)) {
        return true;
      }
    }
    return false;
  }
  
  private async checkXSSExecution(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<boolean> {
    try {
      const page = await this.browserManager.newPage();
      
      // Create a unique marker
      const marker = `vajra_xss_${Date.now()}`;
      const testPayload = payload.replace(/alert\([^)]*\)/g, `window.${marker}=true`);
      
      // Build URL with payload
      const url = this.buildUrlWithPayload(endpoint, param, testPayload);
      
      await page.goto(url, { waitUntil: 'networkidle' });
      
      // Check if our marker was set
      const executed = await page.evaluate(() => {
        return (window as Record<string, unknown>)[`vajra_xss_${Date.now()}`] === true;
      });
      
      await page.close();
      return executed;
    } catch {
      return false;
    }
  }
  
  private determineXSSType(evidence: Evidence, payload: string): VulnerabilityType {
    // Check for DOM-based XSS indicators
    if (payload.includes('document.') || payload.includes('location.')) {
      return 'xss-dom';
    }
    
    // Check if payload is stored (would need multiple requests to verify)
    // For now, assume reflected
    return 'xss-reflected';
  }
  
  // ============================================================================
  // SQL Injection Scanner
  // ============================================================================
  
  private async scanSQLi(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    const evidence = await this.sendPayload(endpoint, param, payload);
    
    if (!evidence) return null;
    
    // Check for SQL error messages
    const sqlErrors = this.detectSQLErrors(evidence.response.body);
    
    // Check for time-based blind SQLi
    const timeBased = await this.checkTimeBasedSQLi(endpoint, param);
    
    // Check for boolean-based blind SQLi
    const booleanBased = await this.checkBooleanBasedSQLi(endpoint, param);
    
    if (sqlErrors.length > 0 || timeBased || booleanBased) {
      const vulnType = sqlErrors.length > 0 ? 'sqli-error' : 
                       timeBased ? 'sqli-time' : 'sqli-blind';
      
      return this.createVulnerability({
        type: vulnType,
        severity: 'critical',
        title: `SQL Injection in ${param.name}`,
        description: `A SQL injection vulnerability was found in the ${param.name} parameter. ${
          sqlErrors.length > 0 ? `Database errors detected: ${sqlErrors.join(', ')}` :
          timeBased ? 'Time-based blind SQL injection confirmed.' :
          'Boolean-based blind SQL injection confirmed.'
        }`,
        url: endpoint.url,
        parameter: param.name,
        payload,
        evidence,
        remediation: 'Use parameterized queries or prepared statements. Never concatenate user input directly into SQL queries.',
      });
    }
    
    return null;
  }
  
  private detectSQLErrors(body: string): string[] {
    const errors: string[] = [];
    const patterns = [
      { pattern: /SQL syntax.*MySQL/i, db: 'MySQL' },
      { pattern: /Warning.*mysql_/i, db: 'MySQL' },
      { pattern: /PostgreSQL.*ERROR/i, db: 'PostgreSQL' },
      { pattern: /Warning.*pg_/i, db: 'PostgreSQL' },
      { pattern: /ORA-\d{5}/i, db: 'Oracle' },
      { pattern: /Microsoft.*ODBC.*SQL Server/i, db: 'MSSQL' },
      { pattern: /Unclosed quotation mark/i, db: 'MSSQL' },
      { pattern: /SQLite.*error/i, db: 'SQLite' },
      { pattern: /sqlite3\.OperationalError/i, db: 'SQLite' },
    ];
    
    for (const { pattern, db } of patterns) {
      if (pattern.test(body)) {
        errors.push(db);
      }
    }
    
    return errors;
  }
  
  private async checkTimeBasedSQLi(endpoint: Endpoint, param: Parameter): Promise<boolean> {
    const baselineEvidence = await this.sendPayload(endpoint, param, 'test');
    if (!baselineEvidence) return false;
    
    const baselineTime = baselineEvidence.response.responseTime;
    
    // Test with sleep payload
    const sleepPayloads = [
      "' OR SLEEP(5)--",
      "'; WAITFOR DELAY '0:0:5'--",
      "' OR pg_sleep(5)--",
    ];
    
    for (const payload of sleepPayloads) {
      const evidence = await this.sendPayload(endpoint, param, payload);
      if (evidence && evidence.response.responseTime > baselineTime + 4000) {
        return true;
      }
    }
    
    return false;
  }
  
  private async checkBooleanBasedSQLi(endpoint: Endpoint, param: Parameter): Promise<boolean> {
    const truePayload = "' OR '1'='1";
    const falsePayload = "' OR '1'='2";
    
    const trueEvidence = await this.sendPayload(endpoint, param, truePayload);
    const falseEvidence = await this.sendPayload(endpoint, param, falsePayload);
    
    if (!trueEvidence || !falseEvidence) return false;
    
    // Check if responses are significantly different
    const trueLengthDiff = Math.abs(
      trueEvidence.response.body.length - falseEvidence.response.body.length
    );
    
    return trueLengthDiff > 100;
  }
  
  // ============================================================================
  // SSRF Scanner
  // ============================================================================
  
  private async scanSSRF(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    // Use a callback URL to detect SSRF
    const callbackId = uuidv4();
    const callbackUrl = `http://vajra-callback.local/${callbackId}`;
    
    const evidence = await this.sendPayload(endpoint, param, callbackUrl);
    
    if (!evidence) return null;
    
    // Check for internal IP disclosure
    const internalIPs = this.detectInternalIPs(evidence.response.body);
    
    // Check for cloud metadata access
    const metadataPayloads = [
      'http://169.254.169.254/latest/meta-data/',
      'http://metadata.google.internal/computeMetadata/v1/',
      'http://100.100.100.200/latest/meta-data/',
    ];
    
    for (const metaPayload of metadataPayloads) {
      const metaEvidence = await this.sendPayload(endpoint, param, metaPayload);
      if (metaEvidence && this.detectCloudMetadata(metaEvidence.response.body)) {
        return this.createVulnerability({
          type: 'ssrf',
          severity: 'critical',
          title: `Server-Side Request Forgery (SSRF) - Cloud Metadata Access`,
          description: `SSRF vulnerability allows access to cloud metadata service. This could lead to credential theft and full cloud account compromise.`,
          url: endpoint.url,
          parameter: param.name,
          payload: metaPayload,
          evidence: metaEvidence,
          remediation: 'Implement strict URL validation, use allowlists for permitted domains, and block access to internal IP ranges and cloud metadata endpoints.',
        });
      }
    }
    
    if (internalIPs.length > 0) {
      return this.createVulnerability({
        type: 'ssrf',
        severity: 'high',
        title: `Server-Side Request Forgery (SSRF) in ${param.name}`,
        description: `SSRF vulnerability detected. Internal IP addresses found in response: ${internalIPs.join(', ')}`,
        url: endpoint.url,
        parameter: param.name,
        payload,
        evidence,
        remediation: 'Implement strict URL validation and use allowlists for permitted domains.',
      });
    }
    
    return null;
  }
  
  private detectInternalIPs(body: string): string[] {
    const ips: string[] = [];
    const patterns = [
      /10\.\d{1,3}\.\d{1,3}\.\d{1,3}/g,
      /172\.(1[6-9]|2\d|3[01])\.\d{1,3}\.\d{1,3}/g,
      /192\.168\.\d{1,3}\.\d{1,3}/g,
      /127\.\d{1,3}\.\d{1,3}\.\d{1,3}/g,
    ];
    
    for (const pattern of patterns) {
      const matches = body.match(pattern);
      if (matches) {
        ips.push(...matches);
      }
    }
    
    return [...new Set(ips)];
  }
  
  private detectCloudMetadata(body: string): boolean {
    const indicators = [
      'ami-id',
      'instance-id',
      'instance-type',
      'local-hostname',
      'public-hostname',
      'iam/security-credentials',
      'computeMetadata',
    ];
    
    return indicators.some(indicator => body.includes(indicator));
  }
  
  // ============================================================================
  // Auth Bypass Scanner
  // ============================================================================
  
  private async scanAuthBypass(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    // Test without authentication
    const noAuthEvidence = await this.sendPayloadWithoutAuth(endpoint, param, payload);
    
    if (!noAuthEvidence) return null;
    
    // Check if protected content is accessible
    if (noAuthEvidence.response.statusCode === 200) {
      const hasProtectedContent = this.detectProtectedContent(noAuthEvidence.response.body);
      
      if (hasProtectedContent) {
        return this.createVulnerability({
          type: 'auth-bypass',
          severity: 'critical',
          title: `Authentication Bypass on ${endpoint.url}`,
          description: `Protected endpoint accessible without authentication. Sensitive data may be exposed.`,
          url: endpoint.url,
          parameter: param.name,
          payload,
          evidence: noAuthEvidence,
          remediation: 'Implement proper authentication checks on all protected endpoints. Use middleware to enforce authentication.',
        });
      }
    }
    
    return null;
  }
  
  private async sendPayloadWithoutAuth(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Evidence | null> {
    // Create a new client without auth headers
    const noAuthClient = axios.create({
      timeout: this.config.scanning.timeout,
      headers: {
        'User-Agent': this.config.scanning.userAgent || 'Vajra/1.0 Security Scanner',
      },
      validateStatus: () => true,
    });
    
    return this.sendPayloadWithClient(noAuthClient, endpoint, param, payload);
  }
  
  private detectProtectedContent(body: string): boolean {
    const indicators = [
      'dashboard',
      'admin',
      'profile',
      'account',
      'settings',
      'user',
      'email',
      'password',
      'api_key',
      'secret',
    ];
    
    const lowerBody = body.toLowerCase();
    return indicators.some(indicator => lowerBody.includes(indicator));
  }
  
  // ============================================================================
  // IDOR Scanner
  // ============================================================================
  
  private async scanIDOR(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    // Test with different IDs
    const testIds = ['1', '2', '100', '999', '0', '-1'];
    const responses: Map<string, Evidence> = new Map();
    
    for (const id of testIds) {
      const evidence = await this.sendPayload(endpoint, param, id);
      if (evidence) {
        responses.set(id, evidence);
      }
    }
    
    // Check if we can access different resources
    const uniqueResponses = new Set(
      Array.from(responses.values()).map(e => e.response.body.length)
    );
    
    if (uniqueResponses.size > 1) {
      // Different responses for different IDs - potential IDOR
      const evidence = responses.get('1') || responses.values().next().value;
      
      if (evidence && this.detectSensitiveData(evidence.response.body)) {
        return this.createVulnerability({
          type: 'idor',
          severity: 'high',
          title: `Insecure Direct Object Reference (IDOR) in ${param.name}`,
          description: `IDOR vulnerability allows accessing other users' data by manipulating the ${param.name} parameter.`,
          url: endpoint.url,
          parameter: param.name,
          payload,
          evidence,
          remediation: 'Implement proper authorization checks. Verify that the authenticated user has permission to access the requested resource.',
        });
      }
    }
    
    return null;
  }
  
  private detectSensitiveData(body: string): boolean {
    const patterns = [
      /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/, // Email
      /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/, // Phone
      /\b\d{3}[-]?\d{2}[-]?\d{4}\b/, // SSN
      /"password"\s*:/i,
      /"api_key"\s*:/i,
      /"secret"\s*:/i,
      /"token"\s*:/i,
    ];
    
    return patterns.some(pattern => pattern.test(body));
  }
  
  // ============================================================================
  // LFI Scanner
  // ============================================================================
  
  private async scanLFI(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    const evidence = await this.sendPayload(endpoint, param, payload);
    
    if (!evidence) return null;
    
    // Check for file content indicators
    const fileIndicators = [
      { pattern: /root:.*:0:0:/i, file: '/etc/passwd' },
      { pattern: /\[boot loader\]/i, file: 'boot.ini' },
      { pattern: /\[extensions\]/i, file: 'win.ini' },
      { pattern: /<\?php/i, file: 'PHP file' },
    ];
    
    for (const { pattern, file } of fileIndicators) {
      if (pattern.test(evidence.response.body)) {
        return this.createVulnerability({
          type: 'lfi',
          severity: 'critical',
          title: `Local File Inclusion (LFI) in ${param.name}`,
          description: `LFI vulnerability allows reading local files. Successfully read ${file}.`,
          url: endpoint.url,
          parameter: param.name,
          payload,
          evidence,
          remediation: 'Never use user input directly in file paths. Use allowlists for permitted files and sanitize all input.',
        });
      }
    }
    
    return null;
  }
  
  // ============================================================================
  // Command Injection Scanner
  // ============================================================================
  
  private async scanCommandInjection(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    // Use time-based detection
    const baseEvidence = await this.sendPayload(endpoint, param, 'test');
    if (!baseEvidence) return null;
    
    const baseTime = baseEvidence.response.responseTime;
    
    const sleepPayloads = [
      '; sleep 5',
      '| sleep 5',
      '`sleep 5`',
      '$(sleep 5)',
      '& ping -n 5 127.0.0.1 &',
    ];
    
    for (const sleepPayload of sleepPayloads) {
      const evidence = await this.sendPayload(endpoint, param, sleepPayload);
      
      if (evidence && evidence.response.responseTime > baseTime + 4000) {
        return this.createVulnerability({
          type: 'command-injection',
          severity: 'critical',
          title: `Command Injection in ${param.name}`,
          description: `Command injection vulnerability allows executing arbitrary system commands.`,
          url: endpoint.url,
          parameter: param.name,
          payload: sleepPayload,
          evidence,
          remediation: 'Never pass user input to system commands. Use safe APIs and input validation.',
        });
      }
    }
    
    return null;
  }
  
  // ============================================================================
  // XXE Scanner
  // ============================================================================
  
  private async scanXXE(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    // Only test endpoints that accept XML
    if (!endpoint.contentType?.includes('xml')) {
      return null;
    }
    
    const xxePayload = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>`;
    
    const evidence = await this.sendPayload(endpoint, param, xxePayload);
    
    if (!evidence) return null;
    
    if (/root:.*:0:0:/i.test(evidence.response.body)) {
      return this.createVulnerability({
        type: 'xxe',
        severity: 'critical',
        title: `XML External Entity (XXE) Injection`,
        description: `XXE vulnerability allows reading local files and potentially executing SSRF attacks.`,
        url: endpoint.url,
        parameter: param.name,
        payload: xxePayload,
        evidence,
        remediation: 'Disable external entity processing in XML parsers. Use JSON instead of XML where possible.',
      });
    }
    
    return null;
  }
  
  // ============================================================================
  // CORS Scanner
  // ============================================================================
  
  private async scanCORS(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    const maliciousOrigins = [
      'https://evil.com',
      'https://attacker.com',
      'null',
    ];
    
    for (const origin of maliciousOrigins) {
      try {
        const response = await this.httpClient.get(endpoint.url, {
          headers: {
            'Origin': origin,
          },
        });
        
        const acao = response.headers['access-control-allow-origin'];
        const acac = response.headers['access-control-allow-credentials'];
        
        if (acao === origin || acao === '*') {
          const severity: SeverityLevel = acac === 'true' ? 'high' : 'medium';
          
          return this.createVulnerability({
            type: 'cors-misconfiguration',
            severity,
            title: `CORS Misconfiguration`,
            description: `The server reflects arbitrary origins in Access-Control-Allow-Origin header${
              acac === 'true' ? ' with credentials allowed' : ''
            }.`,
            url: endpoint.url,
            evidence: {
              request: {
                method: 'GET',
                url: endpoint.url,
                headers: { 'Origin': origin },
              },
              response: {
                statusCode: response.status,
                headers: response.headers as Record<string, string>,
                body: '',
                responseTime: 0,
              },
            },
            remediation: 'Configure CORS to only allow trusted origins. Never reflect arbitrary origins or use wildcards with credentials.',
          });
        }
      } catch {
        // Continue testing
      }
    }
    
    return null;
  }
  
  // ============================================================================
  // Security Headers Scanner
  // ============================================================================
  
  private async scanSecurityHeaders(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    try {
      const response = await this.httpClient.get(endpoint.url);
      const headers = response.headers;
      
      const missingHeaders: string[] = [];
      const requiredHeaders = [
        'strict-transport-security',
        'x-content-type-options',
        'x-frame-options',
        'content-security-policy',
        'x-xss-protection',
      ];
      
      for (const header of requiredHeaders) {
        if (!headers[header]) {
          missingHeaders.push(header);
        }
      }
      
      if (missingHeaders.length > 0) {
        return this.createVulnerability({
          type: 'missing-security-header',
          severity: 'low',
          title: `Missing Security Headers`,
          description: `The following security headers are missing: ${missingHeaders.join(', ')}`,
          url: endpoint.url,
          evidence: {
            request: {
              method: 'GET',
              url: endpoint.url,
              headers: {},
            },
            response: {
              statusCode: response.status,
              headers: headers as Record<string, string>,
              body: '',
              responseTime: 0,
            },
          },
          remediation: 'Add the missing security headers to protect against common web vulnerabilities.',
        });
      }
    } catch {
      // Continue
    }
    
    return null;
  }
  
  // ============================================================================
  // Generic Scanner
  // ============================================================================
  
  private async genericScan(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Vulnerability | null> {
    const evidence = await this.sendPayload(endpoint, param, payload);
    
    if (!evidence) return null;
    
    // Use AI to analyze the response
    const classification = await this.aiEngine.classifyVulnerability(evidence);
    
    if (classification.confidence > 70) {
      return this.createVulnerability({
        type: classification.type,
        severity: classification.severity,
        title: `Potential ${classification.type} Vulnerability`,
        description: classification.reasoning,
        url: endpoint.url,
        parameter: param.name,
        payload,
        evidence,
        remediation: await this.aiEngine.suggestRemediation({
          id: uuidv4(),
          type: classification.type,
          severity: classification.severity,
          title: `${classification.type} Vulnerability`,
          description: classification.reasoning,
          url: endpoint.url,
          evidence,
          remediation: '',
          references: [],
          timestamp: new Date(),
          verified: false,
        }),
      });
    }
    
    return null;
  }
  
  // ============================================================================
  // Helper Methods
  // ============================================================================
  
  private async sendPayload(
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Evidence | null> {
    return this.sendPayloadWithClient(this.httpClient, endpoint, param, payload);
  }
  
  private async sendPayloadWithClient(
    client: AxiosInstance,
    endpoint: Endpoint,
    param: Parameter,
    payload: string
  ): Promise<Evidence | null> {
    try {
      const startTime = Date.now();
      let response: AxiosResponse;
      
      const request: HTTPRequest = {
        method: endpoint.method,
        url: endpoint.url,
        headers: { ...endpoint.headers },
      };
      
      if (param.location === 'query') {
        const url = new URL(endpoint.url);
        url.searchParams.set(param.name, payload);
        request.url = url.toString();
        response = await client.request({
          method: endpoint.method,
          url: request.url,
          headers: request.headers,
        });
      } else if (param.location === 'body') {
        request.body = JSON.stringify({ [param.name]: payload });
        request.headers['Content-Type'] = 'application/json';
        response = await client.request({
          method: endpoint.method,
          url: endpoint.url,
          headers: request.headers,
          data: request.body,
        });
      } else if (param.location === 'header') {
        request.headers[param.name] = payload;
        response = await client.request({
          method: endpoint.method,
          url: endpoint.url,
          headers: request.headers,
        });
      } else {
        response = await client.request({
          method: endpoint.method,
          url: endpoint.url,
          headers: request.headers,
        });
      }
      
      const responseTime = Date.now() - startTime;
      
      return {
        request,
        response: {
          statusCode: response.status,
          headers: response.headers as Record<string, string>,
          body: typeof response.data === 'string' ? response.data : JSON.stringify(response.data),
          responseTime,
        },
      };
    } catch (error) {
      this.logger.debug('Failed to send payload', { error: String(error) });
      return null;
    }
  }
  
  private buildUrlWithPayload(endpoint: Endpoint, param: Parameter, payload: string): string {
    const url = new URL(endpoint.url);
    
    if (param.location === 'query') {
      url.searchParams.set(param.name, payload);
    }
    
    return url.toString();
  }
  
  private createVulnerability(data: {
    type: VulnerabilityType;
    severity: SeverityLevel;
    title: string;
    description: string;
    url: string;
    parameter?: string;
    payload?: string;
    evidence: Evidence;
    remediation: string;
  }): Vulnerability {
    return {
      id: uuidv4(),
      type: data.type,
      severity: data.severity,
      title: data.title,
      description: data.description,
      url: data.url,
      parameter: data.parameter,
      payload: data.payload,
      evidence: data.evidence,
      remediation: data.remediation,
      references: this.getReferences(data.type),
      cwe: this.getCWE(data.type),
      owasp: this.getOWASP(data.type),
      timestamp: new Date(),
      verified: false,
    };
  }
  
  private getReferences(type: VulnerabilityType): string[] {
    const refs: Record<string, string[]> = {
      'xss-reflected': [
        'https://owasp.org/www-community/attacks/xss/',
        'https://cwe.mitre.org/data/definitions/79.html',
      ],
      'sqli-error': [
        'https://owasp.org/www-community/attacks/SQL_Injection',
        'https://cwe.mitre.org/data/definitions/89.html',
      ],
      'ssrf': [
        'https://owasp.org/www-community/attacks/Server_Side_Request_Forgery',
        'https://cwe.mitre.org/data/definitions/918.html',
      ],
    };
    
    return refs[type] || [];
  }
  
  private getCWE(type: VulnerabilityType): string[] {
    const cwe: Record<string, string[]> = {
      'xss-reflected': ['CWE-79'],
      'xss-stored': ['CWE-79'],
      'xss-dom': ['CWE-79'],
      'sqli-error': ['CWE-89'],
      'sqli-blind': ['CWE-89'],
      'sqli-time': ['CWE-89'],
      'ssrf': ['CWE-918'],
      'lfi': ['CWE-98'],
      'command-injection': ['CWE-78'],
      'xxe': ['CWE-611'],
      'idor': ['CWE-639'],
      'auth-bypass': ['CWE-287'],
    };
    
    return cwe[type] || [];
  }
  
  private getOWASP(type: VulnerabilityType): string[] {
    const owasp: Record<string, string[]> = {
      'xss-reflected': ['A03:2021 - Injection'],
      'sqli-error': ['A03:2021 - Injection'],
      'ssrf': ['A10:2021 - Server-Side Request Forgery'],
      'auth-bypass': ['A07:2021 - Identification and Authentication Failures'],
      'idor': ['A01:2021 - Broken Access Control'],
    };
    
    return owasp[type] || [];
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ============================================================================
// Types
// ============================================================================

type ScannerFunction = (
  endpoint: Endpoint,
  param: Parameter,
  payload: string
) => Promise<Vulnerability | null>;

export default VulnerabilityAnalyzer;
